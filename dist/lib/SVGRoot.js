function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React, { Component, createRef } from 'react';
import PropTypes from 'prop-types';
import DragRect from './indicators/DragRect';
import { getBBox } from './Common';
export default class SVGRoot extends Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "state", {
      dragging: false,
      dragOrigin: {
        x: 0,
        y: 0
      },
      dragRect: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }
    });

    _defineProperty(this, "rectToBox", rect => {
      return {
        left: rect.x,
        right: rect.x + rect.width,
        top: rect.y,
        bottom: rect.y + rect.height
      };
    });

    _defineProperty(this, "startDrag", event => {
      this.setState({
        dragInitiated: true,
        dragOrigin: this.computeCoordinates(event)
      });
    });

    _defineProperty(this, "handleDrag", event => {
      const {
        dragInitiated,
        dragOrigin
      } = this.state;
      let {
        dragging
      } = this.state;

      if (dragInitiated && !dragging) {
        dragging = true;
      }

      if (dragging) {
        const current = this.computeCoordinates(event);
        this.setState({
          dragging: true,
          dragRect: {
            x: Math.min(current.x, dragOrigin.x),
            y: Math.min(current.y, dragOrigin.y),
            width: Math.abs(current.x - dragOrigin.x),
            height: Math.abs(current.y - dragOrigin.y)
          }
        });
      }
    });

    _defineProperty(this, "stopDrag", () => {
      const {
        dragging,
        dragRect
      } = this.state;

      if (dragging) {
        const {
          selectables
        } = this.props;
        const dragbox = this.rectToBox(dragRect);
        const toSelect = [];
        selectables.forEach((node, index) => {
          const nodebox = getBBox(node);

          if (this.boxOverlap(dragbox, this.rectToBox(nodebox))) {
            toSelect.push(index);
          }
        });
        this.props.selectIndices(toSelect);
      }

      this.setState({
        dragging: false,
        dragInitiated: false,
        dragRect: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        }
      });
    });

    this.svgRef = createRef();
  }

  overlaps(a, b, x, y) {
    return Math.max(a, x) < Math.min(b, y);
  }

  boxOverlap(a, b) {
    return this.overlaps(a.left, a.right, b.left, b.right) && this.overlaps(a.top, a.bottom, b.top, b.bottom);
  }

  computeCoordinates(mouseEvent) {
    const dim = this.svgRef.current.getBoundingClientRect();
    return {
      x: mouseEvent.clientX - dim.left,
      y: mouseEvent.clientY - dim.top
    };
  }

  render() {
    const {
      width,
      height
    } = this.props;
    const {
      dragging,
      dragRect
    } = this.state;
    const styles = {
      backgroundImage: 'url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5' + 'vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCI+CjxyZWN0IHdpZHRoPSIyMCIgaGVpZ2h0' + 'PSIyMCIgZmlsbD0iI2ZmZiI+PC9yZWN0Pgo8cmVjdCB3aWR0aD0iMTAiIGhlaWdodD0iMTAiIGZpbGw9I' + 'iNGN0Y3RjciPjwvcmVjdD4KPHJlY3QgeD0iMTAiIHk9IjEwIiB3aWR0aD0iMTAiIGhlaWdodD0iMTAiIG' + 'ZpbGw9IiNGN0Y3RjciPjwvcmVjdD4KPC9zdmc+)',
      backgroundSize: 'auto'
    };
    return React.createElement("svg", {
      ref: this.svgRef,
      width: width,
      height: height,
      style: styles,
      onMouseDown: this.startDrag,
      onMouseMove: this.handleDrag,
      onMouseUp: this.stopDrag
    }, this.props.children, dragging && React.createElement(DragRect, dragRect));
  }

}

_defineProperty(SVGRoot, "propTypes", {
  width: PropTypes.number.isRequired,
  height: PropTypes.number.isRequired,
  selectables: PropTypes.arrayOf(PropTypes.object),
  selectIndices: PropTypes.func.isRequired
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvU1ZHUm9vdC5qcyJdLCJuYW1lcyI6WyJSZWFjdCIsIkNvbXBvbmVudCIsImNyZWF0ZVJlZiIsIlByb3BUeXBlcyIsIkRyYWdSZWN0IiwiZ2V0QkJveCIsIlNWR1Jvb3QiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwiZHJhZ2dpbmciLCJkcmFnT3JpZ2luIiwieCIsInkiLCJkcmFnUmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwicmVjdCIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsImV2ZW50Iiwic2V0U3RhdGUiLCJkcmFnSW5pdGlhdGVkIiwiY29tcHV0ZUNvb3JkaW5hdGVzIiwic3RhdGUiLCJjdXJyZW50IiwiTWF0aCIsIm1pbiIsImFicyIsInNlbGVjdGFibGVzIiwiZHJhZ2JveCIsInJlY3RUb0JveCIsInRvU2VsZWN0IiwiZm9yRWFjaCIsIm5vZGUiLCJpbmRleCIsIm5vZGVib3giLCJib3hPdmVybGFwIiwicHVzaCIsInNlbGVjdEluZGljZXMiLCJzdmdSZWYiLCJvdmVybGFwcyIsImEiLCJiIiwibWF4IiwibW91c2VFdmVudCIsImRpbSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFgiLCJjbGllbnRZIiwicmVuZGVyIiwic3R5bGVzIiwiYmFja2dyb3VuZEltYWdlIiwiYmFja2dyb3VuZFNpemUiLCJzdGFydERyYWciLCJoYW5kbGVEcmFnIiwic3RvcERyYWciLCJjaGlsZHJlbiIsIm51bWJlciIsImlzUmVxdWlyZWQiLCJhcnJheU9mIiwib2JqZWN0IiwiZnVuYyJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxPQUFPQSxLQUFQLElBQWdCQyxTQUFoQixFQUEyQkMsU0FBM0IsUUFBNEMsT0FBNUM7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLFlBQXRCO0FBRUEsT0FBT0MsUUFBUCxNQUFxQix1QkFBckI7QUFDQSxTQUFTQyxPQUFULFFBQXdCLFVBQXhCO0FBRUEsZUFBZSxNQUFNQyxPQUFOLFNBQXNCTCxTQUF0QixD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LGlCQUFXLEtBQUtDO0FBUGxCLE9BU0csS0FBS2pELEtBQUwsQ0FBV2tELFFBVGQsRUFVR2pELFlBQVksb0JBQUMsUUFBRCxFQUFjSSxRQUFkLENBVmYsQ0FERjtBQWNEOztBQTNJNEM7O2dCQUExQlAsTyxlQUNBO0FBQ2pCUSxTQUFPWCxVQUFVd0QsTUFBVixDQUFpQkMsVUFEUDtBQUVqQjdDLFVBQVFaLFVBQVV3RCxNQUFWLENBQWlCQyxVQUZSO0FBR2pCOUIsZUFBYTNCLFVBQVUwRCxPQUFWLENBQWtCMUQsVUFBVTJELE1BQTVCLENBSEk7QUFJakJ0QixpQkFBZXJDLFVBQVU0RCxJQUFWLENBQWVIO0FBSmIsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIGNyZWF0ZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmltcG9ydCBEcmFnUmVjdCBmcm9tICcuL2luZGljYXRvcnMvRHJhZ1JlY3QnO1xuaW1wb3J0IHsgZ2V0QkJveCB9IGZyb20gJy4vQ29tbW9uJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU1ZHUm9vdCBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICBzZWxlY3RhYmxlczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9iamVjdCksXG4gICAgc2VsZWN0SW5kaWNlczogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9XG5cbiAgc3RhdGUgPSB7XG4gICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgIGRyYWdPcmlnaW46IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcbiAgICBkcmFnUmVjdDoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3ZnUmVmID0gY3JlYXRlUmVmKCk7XG4gIH1cblxuICBvdmVybGFwcyhhLCBiLCB4LCB5KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KGEsIHgpIDwgTWF0aC5taW4oYiwgeSk7XG4gIH1cblxuICBib3hPdmVybGFwKGEsIGIpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVybGFwcyhhLmxlZnQsIGEucmlnaHQsIGIubGVmdCwgYi5yaWdodCkgJiZcbiAgICAgIHRoaXMub3ZlcmxhcHMoYS50b3AsIGEuYm90dG9tLCBiLnRvcCwgYi5ib3R0b20pXG4gIH1cblxuICByZWN0VG9Cb3ggPSByZWN0ID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogcmVjdC54LFxuICAgICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgICB0b3A6IHJlY3QueSxcbiAgICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgY29tcHV0ZUNvb3JkaW5hdGVzKG1vdXNlRXZlbnQpIHtcbiAgICBjb25zdCBkaW0gPSB0aGlzLnN2Z1JlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IG1vdXNlRXZlbnQuY2xpZW50WCAtIGRpbS5sZWZ0LFxuICAgICAgeTogbW91c2VFdmVudC5jbGllbnRZIC0gZGltLnRvcFxuICAgIH1cbiAgfVxuXG4gIHN0YXJ0RHJhZyA9IChldmVudCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZHJhZ0luaXRpYXRlZDogdHJ1ZSxcbiAgICAgIGRyYWdPcmlnaW46IHRoaXMuY29tcHV0ZUNvb3JkaW5hdGVzKGV2ZW50KVxuICAgIH0pO1xuICB9XG5cbiAgaGFuZGxlRHJhZyA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IHsgZHJhZ0luaXRpYXRlZCwgZHJhZ09yaWdpbiB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgeyBkcmFnZ2luZyB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGlmIChkcmFnSW5pdGlhdGVkICYmICFkcmFnZ2luZykge1xuICAgICAgZHJhZ2dpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChkcmFnZ2luZykge1xuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuY29tcHV0ZUNvb3JkaW5hdGVzKGV2ZW50KTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkcmFnZ2luZzogdHJ1ZSxcbiAgICAgICAgZHJhZ1JlY3Q6IHtcbiAgICAgICAgICB4OiBNYXRoLm1pbihjdXJyZW50LngsIGRyYWdPcmlnaW4ueCksXG4gICAgICAgICAgeTogTWF0aC5taW4oY3VycmVudC55LCBkcmFnT3JpZ2luLnkpLFxuICAgICAgICAgIHdpZHRoOiBNYXRoLmFicyhjdXJyZW50LnggLSBkcmFnT3JpZ2luLngpLFxuICAgICAgICAgIGhlaWdodDogTWF0aC5hYnMoY3VycmVudC55IC0gZHJhZ09yaWdpbi55KVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBzdG9wRHJhZyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRyYWdnaW5nLCBkcmFnUmVjdCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGlmIChkcmFnZ2luZykge1xuICAgICAgY29uc3QgeyBzZWxlY3RhYmxlcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IGRyYWdib3ggPSB0aGlzLnJlY3RUb0JveChkcmFnUmVjdCk7XG4gICAgICBjb25zdCB0b1NlbGVjdCA9IFtdO1xuICAgICAgXG4gICAgICBzZWxlY3RhYmxlcy5mb3JFYWNoKChub2RlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBub2RlYm94ID0gZ2V0QkJveChub2RlKTtcbiAgICAgICAgaWYgKHRoaXMuYm94T3ZlcmxhcChkcmFnYm94LCB0aGlzLnJlY3RUb0JveChub2RlYm94KSkpIHtcbiAgICAgICAgICB0b1NlbGVjdC5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMucHJvcHMuc2VsZWN0SW5kaWNlcyh0b1NlbGVjdCk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICBkcmFnSW5pdGlhdGVkOiBmYWxzZSxcbiAgICAgIGRyYWdSZWN0OiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBkcmFnZ2luZywgZHJhZ1JlY3QgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc3R5bGVzID0ge1xuICAgICAgYmFja2dyb3VuZEltYWdlOiAndXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTUnXG4gICAgICAgICsgJ3ZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSStDanh5WldOMElIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMCdcbiAgICAgICAgKyAnUFNJeU1DSWdabWxzYkQwaUkyWm1aaUkrUEM5eVpXTjBQZ284Y21WamRDQjNhV1IwYUQwaU1UQWlJR2hsYVdkb2REMGlNVEFpSUdacGJHdzlJJ1xuICAgICAgICArICdpTkdOMFkzUmpjaVBqd3ZjbVZqZEQ0S1BISmxZM1FnZUQwaU1UQWlJSGs5SWpFd0lpQjNhV1IwYUQwaU1UQWlJR2hsYVdkb2REMGlNVEFpSUcnXG4gICAgICAgICsgJ1pwYkd3OUlpTkdOMFkzUmpjaVBqd3ZjbVZqZEQ0S1BDOXpkbWMrKScsXG4gICAgICBiYWNrZ3JvdW5kU2l6ZTogJ2F1dG8nXG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICA8c3ZnXG4gICAgICAgIHJlZj17dGhpcy5zdmdSZWZ9XG4gICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgIHN0eWxlPXtzdHlsZXN9XG4gICAgICAgIG9uTW91c2VEb3duPXt0aGlzLnN0YXJ0RHJhZ31cbiAgICAgICAgb25Nb3VzZU1vdmU9e3RoaXMuaGFuZGxlRHJhZ31cbiAgICAgICAgb25Nb3VzZVVwPXt0aGlzLnN0b3BEcmFnfVxuICAgICAgPlxuICAgICAgICB7dGhpcy5wcm9wcy5jaGlsZHJlbn1cbiAgICAgICAge2RyYWdnaW5nICYmIDxEcmFnUmVjdCB7Li4uZHJhZ1JlY3R9IC8+fVxuICAgICAgPC9zdmc+XG4gICAgKTtcbiAgfVxufVxuIl19